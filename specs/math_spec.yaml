before: |
  base_module  = "math"
  this_module  = "std.math"
  global_table = "_G"

  extend_base  = { "floor", "monkey_patch", "round" }

  M = require (this_module)

specify std.math:
- context when required:
  - context by name:
    - it does not touch the global table:
        expect (show_apis {added_to=global_table, by=this_module}).
          to_equal {}
    - it does not touch the core math table:
        expect (show_apis {added_to=base_module, by=this_module}).
          to_equal {}
    - it contains apis from the core math table:
        expect (show_apis {from=base_module, not_in=this_module}).
          to_contain.a_permutation_of (extend_base)

  - context via the std module:
    - it does not touch the global table:
        expect (show_apis {added_to=global_table, by="std"}).
          to_equal {}
    - it does not touch the core math table:
        expect (show_apis {added_to=base_module, by="std"}).
          to_equal {}


- describe floor:


- describe monkey_patch:
  - before:
      f  = M.monkey_patch
      t  = {
        math = {},
      }
      f (t)
  - it installs math.floor function:
      expect (t.math.floor).to_be (M.floor)
  - it diagnoses non-table argument:
      expect (f "bad").to_error "table expected"


- describe round:
