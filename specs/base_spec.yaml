before:
  base = require "std.base"

specify std.base:
- describe deprecate:
  - before: |
      deprecate = base.deprecate

      function runscript (body, name, args)
        return luaproc (
          "require 'std.base'.deprecate (function (...)" ..
          " " .. body ..
          " end, '" .. (name or "runscript") .. "') " ..
          "('" .. table.concat (args or {}, "', '") .. "')"
        )
      end
  - it diagnoses missing arguments:
      expect (deprecate ()).to_error "missing argument"
  - it returns a function:
      f = deprecate (base.clone_rename, "clone_rename")
      expect (type (f)).to_be "function"
  - context with deprecated function:
    - it executes the deprecated function:
        expect (runscript 'error "oh noes!"').to_contain_error "oh noes!"
    - it passes arguments to the deprecated function:
        expect (runscript ("print (table.concat ({...}, ', '))", nil,
                           {"foo", "bar", "baz"})).to_output "foo, bar, baz\n"
    - it returns deprecated function results:
        script = [[
          deprecate = require "std.base".deprecate
          fn = deprecate (function () return "foo", "bar", "baz" end, "fn")
          print (fn ())
        ]]
        expect (luaproc (script)).to_output "foo\tbar\tbaz\n"
    - it writes a warning to stderr:
        expect (runscript 'error "oh noes!"').
          to_contain_error "deprecated, and will go away"
    - it writes the call location to stderr: |
        expect (runscript 'error "oh noes!"').
          to_match_error "^%S+:1: "
    - it does not repeat the warning on additional calls:
        script = [[
          deprecate = require "std.base".deprecate
          fn = deprecate (function () error "oh noes!" end, "fn")
          fn ()  -- line 3
          fn ()  -- line 4
        ]]
        expect (luaproc (script)).
          not_to_match_error "^%S+:3:.*deprecated.*\n%S+:4:.*deprecated"
